#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>

typedef uint64_t Bitmask;
typedef uint16_t LogEst;
typedef int8_t i8;

typedef struct WhereLoop WhereLoop;
typedef struct WherePath
{
	Bitmask maskLoop;     /* Bitmask of all WhereLoop objects in this path */
	Bitmask revLoop;      /* aLoop[]s that should be reversed for ORDER BY */
	LogEst nRow;          /* Estimated number of rows generated by this path */
	LogEst rCost;         /* Total cost of this path */
	LogEst rUnsort;       /* Total cost of this path ignoring sorting costs */
	i8 isOrdered;         /* No. of ORDER BY terms satisfied. -1 for unknown */
	WhereLoop** aLoop;    /* Array of WhereLoop objects implementing this path */
} WherePath;

bool test(int nOrderBy, int nLoop, int mxChoice)
{
	int ii, jj;               /* Loop counters */
	WherePath* aFrom;         /* All nFrom paths at the previous level */
	WherePath* aTo;           /* The nTo best paths at the current level */
	WherePath* pFrom;         /* An element of aFrom[] that we are working on */
	WherePath* pTo;           /* An element of aTo[] that we are working on */
	WhereLoop** pX;           /* Used to divy up the pSpace memory */
	char* pSpace;             /* Temporary memory used by this routine */
	int nSpace;               /* Bytes of space allocated at pSpace */

	nSpace = (sizeof(WherePath) + sizeof(WhereLoop*) * nLoop) * mxChoice * 2;
	nSpace += sizeof(LogEst) * nOrderBy;
	pSpace = (char*)malloc(nSpace);

	aTo = (WherePath*)pSpace;
	aFrom = aTo + mxChoice;
	memset(aFrom, 0, sizeof(aFrom[0]));
	pX = (WhereLoop**)(aFrom + mxChoice);
	for (ii = mxChoice * 2, pFrom = aTo; ii > 0; ii--, pFrom++, pX += nLoop) {
		pFrom->aLoop = pX;
	}

	printf("pFrom: %p\n", pFrom);
	printf("aFrom: %p\n", aFrom);
	printf("aTo: %p\n", aTo);

	for (int iLoop = 0; iLoop < nLoop; iLoop++) {
		pFrom = aTo;
		aTo = aFrom;
		aFrom = pFrom;
	}

	printf("pFrom: %p\n", pFrom);
	printf("aFrom: %p\n", aFrom);
	printf("aTo: %p\n", aTo);

	return false;
}

int main(void)
{
	test(0, 1, 1);
}
